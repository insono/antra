/*
1. Joins because they are less resource intensive
2. CTE is common table exxpression and you use it to create a recursive query
3. A table variable is a data type that can be used within a Transact-SQL batch, stored procedure, or function—and is created and defined similarly to a table, only with a strictly defined lifetime scope
4. Truncate reseeds identity values, whereas delete doesn't. Truncate is faster compared to delete as it makes less use of the transaction log.
5. An identity column is a column (also known as a field) in a database table that is made up of values generated by the database. Truncate reseeds identity values, whereas delete doesn't.
6. Truncate removes everything, but delete can remove specific rows. Truncate removes all records and doesn't fire triggers.
*/

use Northwind;
--1
select distinct e.City
from Employees e
join Customers c
on e.City = c.City

--2a
select distinct c.City
from Customers c
where c.City not in 
	(select distinct e.City
	from Employees e)

--2b
select distinct c.City
from Customers c
join Employees e
on c.City != e.City

--3
select ProductName, SUM(Quantity) as totalOrders
from [Order Details] od
join Products p 
on od.ProductID = p.ProductID
group by ProductName

--4
select c.City, SUM(Quantity) as totalOrders
from Customers c
join Orders o
on c.CustomerID = o.CustomerID
join [Order Details] od
on o.OrderID = od.OrderID
group by c.City

--5a
select c.City
from Customers c
group by c.City
having count(CustomerID) > 1
union
select c2.City
from Customers c2
group by c2.City
having count(CustomerID) > 1

--5b
select distinct c.City
from Customers c
where c.City in (select City
				from Customers 
				group by City
				having count(CustomerID) > 1)

--6
select c.City
from Customers c
left join Orders o
on c.CustomerID = o.CustomerID
join [Order Details] od
on o.OrderID = od.OrderID
group by c.City
having count(ProductID) > 1

--7
select distinct c.ContactName
from Customers c
left join Orders o
on c.CustomerID = o.CustomerID
where City != ShipCity

--8
select top 5 ProductName, avg(p.UnitPrice) as 'AvgPrice', count(od.OrderID) as 'totalOrders', c.City
from Products p
join [Order Details] od on p.ProductID = od.ProductID
join Orders o on od.OrderID = o.OrderID
join Customers c on o.CustomerID = c.CustomerID
group by ProductName, c.City
order by totalOrders desc

--9a
select City
from Employees
where City not in (select ShipCity from Orders)

--9b
select e.City
from Employees e
left join Orders o on e.City = o.ShipCity
where ShipCity is null

--10
select top 1 City
from Orders o
join [Order Details] od on o.OrderID = od.OrderID
join Employees e on o.EmployeeID = e.EmployeeID
group by e.EmployeeID, e.City
order by count(o.EmployeeID) desc

/*
#11
If I use rank and a partition clause, I can give count each distinct row and remove those with rank > 1 with a delete

#12
select empid
from employee
where mgrid is null

#13
select deptname, count(e.deptid) as deptEmployees
from dept d
join employee e on e.deptid = d.deptid
group by deptid
order by deptEmployees desc

#14
select top 3 d.deptname, e.empid, e.salary
from employee e
join dept d on e.deptid = d.deptid
order by e.deptid, e.salary desc
*/